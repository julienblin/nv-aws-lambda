import { camelCase } from "change-case";
import { readFileSync, writeFileSync } from "fs";
import * as glob from "glob";
import * as YAML from "js-yaml";
import { EOL } from "os";
import * as path from "path";
import * as toposort from "toposort";
import * as ts from "typescript";
import * as TJS from "typescript-json-schema";

export interface SchemaGenerationOptions {
  /** Path to tsconfig.json */
  config?: string;
  files: string;
  format: "json" | "yaml" | "ts" | "openapi3";
  out?: string;
}

export class SchemaGeneration {

  public constructor(private readonly options: SchemaGenerationOptions) { }

  public run(): string {
    const allFiles = glob.sync(this.options.files).map((x) => path.resolve(x)).map(this.normalizeFileName);
    const program = TJS.getProgramFromFiles(allFiles, this.getCompilerOptions());
    const generator = TJS.buildGenerator(program, { noExtraProps: true, required: true })!;
    const mainFileSymbols = generator.getMainFileSymbols(program, allFiles);
    const jsonSchema = generator.getSchemaForSymbols(mainFileSymbols);
    delete jsonSchema.$schema;

    switch (this.options.format) {
      case "json":
        return JSON.stringify(jsonSchema, undefined, 2);
      case "yaml":
        return YAML.safeDump(jsonSchema);
      case "ts":
        return this.tsFormat(jsonSchema);
      case "openapi3":
        return this.openApi3Schemas(jsonSchema, this.options.out);
      default:
        throw new Error("Unsupported format: " + this.options.format);
    }
  }

  private normalizeFileName(fn: string): string {
    while (fn.substr(0, 2) === "./") {
      fn = fn.substr(2);
    }
    return fn.replace(/\\/g, "/");
  }

  private getCompilerOptions() {
    if (!this.options.config) {
      return ({ strictNullChecks: true });
    }

    const parseResult = ts.parseConfigFileTextToJson(this.options.config, ts.sys.readFile(this.options.config)!);
    const config = ts.parseJsonConfigFileContent(
      parseResult.config, ts.sys, path.dirname(this.options.config), {}, path.basename(this.options.config));

    const options = config.options;
    options.noEmit = true;
    delete options.out;
    delete options.outDir;
    delete options.outFile;
    delete options.declaration;

    return options;
  }

  /* Formats a jsonSchema as a tslint-compatible Typescript file. */
  private tsFormat(jsonSchema: TJS.Definition): string {
    const lines: CodeLine[] = [];

    lines.push([0, "/**"]);
    lines.push([0, " * This code was generated by the uno cli."]);
    lines.push([0, " *"]);
    lines.push([0, " * Manual changes may cause incorrect behavior and will be lost if"]);
    lines.push([0, " * the code is regenerated."]);
    lines.push([0, " */"]);
    lines.push();
    lines.push([0, "// tslint:disable"]);

    const orderedSchemas = this.orderSchemas(jsonSchema.definitions || {});

    Object.keys(orderedSchemas).forEach((key) => {
      lines.push(null);
      lines.push([0, `export const ${this.schemaIdentifier(key)} = {`]);
      this.tsSchema(lines, 1, jsonSchema.definitions![key]);
      lines.push([0, `};`]);
    });

    return this.formatCodeLines(lines);
  }

  /* Order the schemas based on their dependencies using a toposort. */
  private orderSchemas(schemas: any): any {
    const dependencies: string[][] = [];
    Object.keys(schemas).forEach((s) => {
      const refSchemas = this.getRefSchemas(schemas[s]);
      if (refSchemas.length === 0) {
        dependencies.push([s]);
      } else {
        refSchemas.forEach((ref) => {
          dependencies.push([s, ref]);
        });
      }
    });

    return toposort(dependencies)
      .filter((x) => !!x)
      .reverse()
      .reduce(
        (acc, cur) => {
          acc[cur] = schemas[cur];
          return acc;
        },
        {});
  }

  /* Gets the referenced schemas */
  private getRefSchemas(schemaObj: any): string[] {
    const result: string[] = [];
    Object.keys(schemaObj).forEach((prop: any) => {
      const value = schemaObj[prop];
      if (typeof value === "object") {
        if (value.$ref) {
          result.push(value.$ref.replace("#/definitions/", ""));
        } else {
          result.push(...this.getRefSchemas(value));
        }
      }
    });
    return [...new Set(result)];
  }

  private schemaIdentifier(name: string) {
    return `${camelCase(name)}Schema`;
  }

  private tsSchema(lines: CodeLine[], indent: number, value: any) {
    Object.keys(value).sort().forEach((prop) => {
      lines.push([indent, `${prop}: ${this.tsValue(lines, indent + 1, value[prop])},`]);
    });
  }

  private tsValue(lines: CodeLine[], indent: number, value: any) {
    if (Array.isArray(value)) {
      return `[${value.map((x) => this.tsValue(lines, indent + 1, x)).join(", ")}]`;
    }

    switch (typeof value) {
      case "string":
      case "symbol":
        return `"${value.replace(/\r?\n|\r/g, " ")}"`;
      case "number":
      case "boolean":
        return value.toString();
      case "object":
        if (value.$ref) {
          return this.schemaIdentifier(value.$ref.replace("#/definitions/", ""));
        } else {
          const localLines: CodeLine[] = [[0, "{"]];
          this.tsSchema(localLines, indent, value);
          localLines.push([indent - 1, "}"]);
          return this.formatCodeLines(localLines, false);
        }
    }
  }

  private formatCodeLines(lines: CodeLine[], lastLineEOL = true): any {
    let result = "";
    lines.forEach((line, index) => {
      if (line) {
        result += `${"  ".repeat(line[0])}${line[1]}`;
        if ((index < (lines.length - 1)) || lastLineEOL) {
          result += EOL;
        }
      } else {
        result += EOL;
      }
    });
    return result;
  }

  private openApi3Schemas(jsonSchema: TJS.Definition, out?: string): string {
    const replaceDefinitionsRef = (schemaObj: any) => {
      Object.keys(schemaObj).forEach((prop: any) => {
        const value = schemaObj[prop];
        if (typeof value === "object") {
          if (value.$ref) {
            value.$ref = value.$ref.replace("#/definitions/", "#/components/schemas/");
          } else {
            replaceDefinitionsRef(value);
          }
        }
      });
    };

    const sortedProperties = Object.keys(jsonSchema.definitions!)
      .sort()
      .reduce((acc, cur) => { acc[cur] = jsonSchema.definitions![cur]; return acc; }, {});

    replaceDefinitionsRef(sortedProperties);

    if (out) {
      const openAPIFile = YAML.safeLoad(readFileSync(out).toString());
      openAPIFile.components.schemas = {
        ...openAPIFile.components && openAPIFile.components.schemas,
        ...sortedProperties,
      };
      writeFileSync(out, YAML.safeDump(openAPIFile));
    }

    return YAML.safeDump(sortedProperties);
  }
}

type CodeLine = [number, string] | null;
